# 面向对象的编程（中）

项目二在**Day11 **中。

## 5.1 面向对象特征之二：继承性

1. 继承性的好处：

   * 减少代码冗余，提高代码的复用性
   * 便于功能的拓展
   * 为之后多态的使用，提供了前提

2. 继承性的格式：class A extends B{}

   * 子类、派生类、subclass
   * 父类、超类、基类、superclass

   体现“一旦子类继承父类以后，子类中就获取了父类中声明的结构：所有属性和方法

   私有结构，继承后仍然认为获取了父类的私有结构。由于封装性不能直接调用。

   子类继承父类后，可以声明自己特有的属性或方法，实现功能的拓展。

3. Java中关于继承的规定

   * 一个类可以被多个子类继承。
   * 一个类只能有一个父类：单继承；C++多继承。
   * 子父类是相对的概念。
   * 子类直接继承的父类，称为：直接父类。间接继承的父类称为间接父类。
   * 子类继承父类以后，就获取了直接父类以及间接父类中声明的属性和方法。

4. * 如果没有显示的声明一个类的父类，则此类继承于Java.lang.Object类。
   * 所有的java类都直接或间接的继承于Java.lang.Object类。
   * 意味着所有的Java类都具有Java.lang.Object类声明的功能。

# 5.2 方法的重写

定义：子类中对从父类中继承来的方法进行改造，称方法的重置、覆盖。

应用：重写以后，创建子类对象实际调用的是子类重写的方法。

**面试题**：区分面试的重载与重写？多态性

具体规则：

* 方法的声明：权限修饰符 返回值类型 方法名（形参列表） throws 异常的类型{

  ​             //方法体

  }

  约定俗成：子类中的叫重写的方法，父类中的叫被重写的方法

* 子类重写方法的**方法名**和形**参列表**与父类中相同

* 子类重写方法的**权限修饰符不小于**不小于父类：子类不能重写父类中private权限的方法

* 返回值类型：

  * 父类void    子类void
  * 父类A   子类为A或A的子类
  * 父类 基本数据类型  父类 相同基本数据类型

* **子类重写方法抛出的异常类型不大于父类被重写方法抛出的异常类型（异常处理讲解）**

子类和父类中同名同参数的方法，要么都是非static（考虑重写）， 要么是static（不是重写）

## 5.3 四种访问权限修饰符

private<缺省<protected<public

![20210320](file://D:\Learn\Java\笔记\20210320.jpg?lastModify=1616500138)

## 5.4 super关键字

1. 理解为：父类的
2. super可以用来调用属性、方法、构造器。
3. super的使用
   * 我们可以在子类的方法或构造器中。通过使用”super.属性“或”super.方法“的方式，显式的调用父类中声明的属性或方法。但是，通常情况下，习惯省略”super.“
   * **特殊情况：**子类和父类都有的情况下，必须用super调用父类
4. super调用构造器：
   * 在子类的构造器中显式的使用”super（形参列表）“的方式，调用父类中声明的指定构造器
   * ”super（形参列表）“的使用，必须声明在子类构造器的首行
   * 在类的构造器中，针对于”this.（形参列表）“和”super（形参列表）“只能二选一
   * 默认调用的是父类中的空参构造器。
   * 在类的多个构造器中，至少有一个构造器使用”super（形参列表）“。

## 5.5 子类对象的实例化

1. **结果：**子类继承父类后，获取了父类中声明的属性和方法。创建子类的对象，会在堆空间中加载所有父类声明的属性。
2. **过程：**通过子类构造创建子类对象时，一定会直接或间接调用父类的构造器，直到调用了Java.lang.Object类中空参的构造器为止。

注意：虽然调用了父类构造器，但是最终只造了一个对象。

## 5.6 面向对象的特征之三：多态性

一个事物的多种形态。

对象的多态性：**父类的引用指向子类的对象Person p2 = new Man();**

多态的使用：调用子父类同名同参数的方法时，实际执行的是子类重写父类的方法---虚拟方法调用

编译看左边声明的类型，运行执行的是另一层。

**使用：**有了对象的多态性以后，编译看左边声明的类型，运行看右边。

**使用前提：**

* 类的继承关系
* 方法的重写

对象的多态性只适用于方法，**不适用于属性**。**编译运行都看左边。**

被重写的方法被称为**虚方法**

多态是运行时行为------动态绑定

重载：编译期间绑定调用地址，”早绑定“，”静态绑定“

重写：”晚绑定“，”动态绑定“

回顾：

**子类可以获取父类中private的属性和方法**

**面试题：重载和重写的区别？**

答：1. 二者的概念。2. 重载和重写的规则 3. 重载：不表现为多态性，重写：表现为多态性。

### instanceof操作符

不能调用子类所特有的方法、属性；编译时是父类。

**有了对象的多态性以后，内存中实际上是加载了子类特有的属性和方法，但由于变量声明为父类类型，导致编译时，只能调用父类中声明的属性和方法。子类所特有的方法、属性不能调用**

如何调用子类特有的属性和方法？

**向下转型（强制类型转换）：**Man m1 = (Man)p2;

**向上转型：**多态

使用强转时可能出现ClassCastException的异常。

**instanceof关键字的使用**

```java
a instanceof A;//判断对象a是否是类A的实例。如果是，返回true，如果不是，返回false。
```

**注意：**

* 为了避免向下转型时出现ClassCastException异常，在向下转型之前，先进行instanceof的判断，一旦返回true，进行向下转型。如果返回false，不进行向下转型。

* 如果a instanceof A返回true；a instanceof B 也返回true,则B是A的父类。

实际不相关的转型不会成功。

**引用数据类型的”==“判断的是地址值是否相等**

1. 子类重写了父类的方法后，系统不可能不父类的方法转移到子类中。
2. 对实例变量，不可能覆盖。

## 5.7 Object类的使用

1. Object类是所有Java的根父类。
2. 默认父类为java.lang.Object类。
3. 类中的功能具有通用性。
4. Object类只声明了一个空参构造器。
   * clone()；**equals()**；**toString()**；getClass()；hashcode()；finalize()垃圾收集器，对象被回收之前调用；
   * **面试题：final、finally、finalize的区别？**

### 1. ==和equals（）的区别

**==：运算符**

1. 可以使用在基本数据类型变量和引用数据类型变量。
2. 如果比较的是基本数据类型变量，比较保存的数据是否相等（数据类型不一定相等）。
3. 引用数据类型，比较地址值。
4. **保证变量类型能够一致**，否则编译会报错

**equals（）方法**

1. 是一个方法，不是运算符。

2. 只适用于引用数据类型。

3. Object类中equals（）方法定义与==相同，比较地址值；String、Date、File、包装类等，都重写了equals（）比较实际的内容。

4. 自定义类重写：

   ```java
   public boolean equals(Object obj){
       if(this == obj){
           return true;
       }
       if(obj instanceof Customer){
           Customer cust = (Customer)obj;
           return this.age == cust.age && this.name.equals(cust.name);
       }
       return false;
   }
   ```

### 2. toString（）的使用

1. 当输出一个对象的引用时，实际上是调用当前对象的toString（）

2. 定义：

   ```java
   public String toString(){
       return getClass().getName()+"@"+Integer.toHexString(hashCode());
   }
   ```

3. String 、Date、File、包装类等都重写了toString（）方法。调用该方法时都返回“实体内容”。

## 5.8 包装类的使用

### 1. 单元测试Junit

步骤：

1. 选中当前工程-右键选择：build path - add libraries - Junit 4 -下一步
2. 创建Java类，进行单元测试。（要求：public类；提供公共的无参构造器）
3. 在此类中声明单元测试方法。（要求：public方法，没有返回值，没有形参；testXxx）
4. 此单元测试方法上需要声明注解：@Test，并在单元测试类中导入：import org.junit.Test；
5. 声明好后，在方法体内测试相关的代码。
6. 双击方法名，测试

说明：

1. 结果没有异常，绿条
2. 出现异常，红条。

### 2.包装类

包装类的使用：

1. Java有八种数据类型的包装类，使得基本数据类型的变量具有类的特征

   ![202103241](D:\Learn\Java\笔记\202103241.png)

2. 掌握的：基本数据类型、包装类、String三者之间的相互转换。

Boolean:在非null的情况下，忽略true中的大小写，其余不一样的都是false

基本数据类型转化为包装类：

```java
Integer in2 = new Integer(num1);
```

包装类转化为基本数据类型：

```java
in1.inrValue();
```

JDK5.0新特性：**自动装箱与拆箱**

```java
int num = 10;
Integer in2 = num1;//装箱
int num3 = in2;
```

3. 基本数据类型转换到String
   * 方式1：连接运行+
   * 方式2：**String.valueOf(Xxx xxx)**
4. String怎么转换为基本数据类型
   * 调用包装类中的**parseInt(Xxx)**方法

三目运算符需要输出同一类型。自动类型提升。  

**题目：**

![202103242](D:\Learn\Java\笔记\202103242.png)

多态：

* 实现代码的通用性

* Object类中定义的public boolean equals（Object obj）{}

  JDBC:使用Java操作数据库。

* 抽象类、接口的使用肯定体现了多态性。

**数组可以看作特殊的类**