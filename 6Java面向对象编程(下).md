# 面向对象编程（下）

## 6.1 关键字：static

static关键字的使用，**修饰类的内部结构**

1. 静态的

2. 用来修饰：属性、方法、代码块、内部类

3. 使用static修饰属性：静态变量、类变量

   **属性：**是否使用static修饰分为：静态属性和非静态属性（实例变量）

   **实例变量：**每个对象用于一套非静态属性，修改一个不会改变其他。

   **静态变量：**每个对象共享同一个静态变量。某一个对象修改时，其他对象的也会被修改。

   **其他说明：**

   * 静态变量随着**类的加载而加载**，可以通过“类.静态变量”的方式进行调用
   * 静态变量的加载要**早于对象的创建。**
   * 由于类只会加载一次，则静态变量也只会存在一份，**存在方法区的静态域中**。
   * 静态属性举例：System.out.println();Math.PI;通过类可以直接调用。

   **栈：局部变量；堆：new出来的结构：对象、数组；方法区：类的加载信息、静态域、常量池**

4. 使用static修饰方法：静态方法

   * 静态变量随着类的加载而加载，可以通过“类.静态方法”的方式进行调用
   * 静态方法中：只能调用静态属性和方法；非静态方法中，都可以调用

5. 静态方法内不能使用this和super；理解生命周期。

6. 开发中如何确定属性是否应该为static？

   * 属性可以被多个对象共享，不会因对象不同而不同
   * 类中的常量也常常声明为static

7. 开发中如何确定方法是否应该为static？

   * 操作静态属性的方法，设置为static

   * 工具类中的方法，习惯上声明为static。比如Math、Arrays、Collection

### 单例设计模式（23种）

**定义：**采取一定的方法保证整个软件系统中，对某个类**只能存在一个对象实例。**

（私有化private static）

**优点：**减少系统性能开销；

**饿汉式：**

1. 私有化类的构造器。
2. 内部创建类的对象（私有化private static）。
3. 提供公共方法，返回对象（public static）。

**懒汉式：**

1. 私有化类的构造器。
2. 声明当前类的对象，不用new（私有化private static  =  null）。
3. 提供公共方法，返回对象（public static）if 对象==null，创建；如果有则不操作。

**区分饿汉式和懒汉式：**

* 饿汉式：缺点：对象加载时间过长。优点：线程安全。

* 懒汉式：优点：延迟对象的创建。 缺点：目前写法坏处，线程不安全。

**典型应用：**

* 网站计数器
* 应用程序日志应用
* 数据库连接池
* 读取配置文件的类
* Application
* 任务管理器
* 回收站

## 6.2 理解main方法的使用

使用说明：

1. main方法作为程序的入口
2. 也是一个普通的静态方法
3. main方法可以作为与控制台交互的方法。（之前使用Scanner）

## 6.3 类成员之四：代码块

1. 代码块的作用：用来初始化类、对象

2. 代码块如果有修饰的话，只能使用static

3. 分类：静态代码块sastic{}和非静态代码块

   * 静态代码块

   内部可以有输出语句；随着对象加载而**执行**，而且只执行一次

   作用：初始化类的信息；**多个按照先后顺序执行**。

   静态代码块内只能调用静态结构，不能调用非静态

   * 非静态代码块

   内部可以有输出语句；随着对象的创建而**执行**；每创建一个对象就执行一次

   作用：可以在创建对象时，对对象的属性等初始化。

   可以调用静态与非静态

   **多个按照先后顺序执行。**

**属性可以赋值的位置：**

* 默认初始化
* 显式初始化
* 在代码块中赋值
* 构造器中初始化
* 有了对象后，可以通过对象.属性或方法赋值

由父及子，静态先行。

## 6.4 关键字：final

1. 修饰类、方法、变量。
2. final用来修饰一个类，**不能被其他类继承**（String、System、StringBuffer）。
3. final修饰方法：表明该方法**不能被重写**。
4. final用来修饰变量：此时的”变量“称为”一个**常量**
   * final 修饰属性：可以考虑赋值的位置：显示初始化、代码块中赋值、构造器中初始化
   * final 修饰局部变量：不能再赋值；修饰形参时，表明形参是一个常量，不能重写赋值

static final 修饰常量：全局常量

## 6.5 抽象类与抽象方法abstract

有的累没有具体的实例：抽象类；abstract

1. 抽象的
2. 修饰结构：类、方法
3. 修饰类：此类不能实例化；抽象类中一定有构造器，便于子类实例化调用；开发中都会提供抽象类子类。
4. 抽象方法：只有方法的声明，没有方法体没有{}；包含抽象方法的类，一定是一个抽象类；抽象类中可以没有抽象方法；若子类重写父类中的抽象方法后，此子类可以实例化，反之也是一个抽象类。

**注意：**

* abstract不能用来修饰：属性、构造器等结构。
* 不能用来修饰私有方法、静态方法、final的方法、final的类

抽象类的匿名子类

```java 
Person p = new Person(){//匿名子类的对象：p
    public void eat()
    {
        
    }
    
    public void breath()
    {
        
    }
}
```

匿名子类的匿名对象：

```java 
method1(new Person(){
     public void eat()
    {
        
    }
    
    public void breath()
    {
        
    }
});
```

### 多态的应用：模板方法设计模式

抽象类的应用：模板

## 6.6 接口interface

接口使用：

1. 接口使用interface来定义

2. 接口和类并列

3. 如何定义接口的成员：

   * JDK7及以前：只能定义全局常量和抽象方法

     public static final；**可以省略**

     public abstract

     ```java
     package com.atguigu.java1;
     
     public class InterfaceTest {
     	public static void main(String[] args){
     		System.out.println(Flyable.MAX_SPEED);
     		System.out.println(Flyable.MIN_SPEED);
     		
     	}
     }
     
     interface Flyable{
     	
     	//全局常量
     	public static final int MAX_SPEED = 7900;//第一宇宙速度
     	int MIN_SPEED = 1;//省略public static final
     	
     	//抽象方法
     	public abstract void fly();
     	
     	//省略public abstract
     	void stop();
     }
     ```

     

   * JDK8：还可以定义静态方法、默认方法（略）

     **接口中定义的静态方法只能通过接口调用。**

     **默认方法可以通过对象调用,可以重写默认接口方法**

     **子类或者实现类继承的父类和实现的接口中声明了同名同参数的方法，那么子类在没有重写此方法的情况下，默认调用父类中同名同参数的方法**

     实现类实现类多个接口，有同样的方法会出现接口冲突；必须在实现类中重写此方法

     **调用接口中的默认方法：接口名.super.默认方法名()**

     ```java
     package com.atguigu.java8;
     
     import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter.DEFAULT;
     
     public interface CompareA {
     	public static void method1(){
     		System.out.println("111");
     	}
     	//默认方法
     	public default void method2(){
     		System.out.println("222");
     	}
     	default void method3(){
     		System.out.println("333");
     	}
     }
     
     ```

     

4. 接口不能定义构造器！意味着不可以实例化。

5. Java开发中，类实现接口implements。

   如果实现类覆盖了接口的所有抽象方法，则此实现类可以实例化

   ```java
   class Plane implements Flyable{
   	@Override
   	public void fly()
   	{
   		System.out.println("起飞");
   	}
   	@Override
   	public void stop()
   	{
   		System.out.println("停止");
   	}
   }
   ```

6. Java类可以实现多个接口，弥补单继承性

   格式：class AA extends BB  implements CC,DD,EE

7. 接口和接口之间可以**多继承**  interface CC extends AA,BB

**接口的使用**

1. 接口的具体使用，体现多态性
2. 接口，实际上可以看成一种规范
3. 开发中，体会面向接口编程

**面试题：**抽象类和接口有那些异同？

同：不能实例化，都可以被继承

不同：抽象类：有构造器，单继承。接口：不能声明构造器、多继承

**抽象类可以继承非抽象类。**

### 代理模式

为其他对象提供一种代理以控制这个对象的访问                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        

### 工厂设计模式

创建者与调用者分离，

**题目：**

接口和父类中的属性同名；super调用父类、接口名直接调用接口中的属性

接口中都是常量

## 6.7 内部类

1. 将类A声明在另一个类B中，A为内部类
2. 成员内部类（静态、非静态）VS局部内部类（方法内、代码块内、构造器内）
3. 成员内部类：
   * 外部类的成员：调用外部类的结构、静态只能调用静态、可以用static修饰、被四种权限修饰。
   * 作为一个类：可以定义属性、方法、构造器等；可以被final修饰；可以被abstract修饰、
4. 关注：
   * 如何实例化成员
   * 如何在成员内部类中区分调用外部类的结构
   * 开发中内部类的使用

总结：

* 成员内部类和局部内部类，在编译后，都会生成字节码文件
* 局部内部类的方法中，如果调用局部内部类声明的方法中的局部变量，要求此局部变量声明为final。JDK7之前要求写出final JDK8可以省略final